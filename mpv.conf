# ============================================================================
# mpv Broadcast Suite Configuration
# ============================================================================
# Professional configuration for broadcast engineers and QC operators
#
# Optimised for:
#   • Frame-accurate review and quality control workflows
#   • Multi-channel audio monitoring and mapping
#   • High-quality screenshot capture for reporting
#   • Stable, reproducible playback across sessions
#
# Author:  David Thåst and contributors
# GitHub:  https://github.com/FiLORUX/mpv-broadcast-suite
# License: MIT
# Version: 2.0.0
# ============================================================================

# ============================================================================
# VIDEO OUTPUT & RENDERING
# ============================================================================

# Video output driver
# Specifies which backend mpv uses to render video frames to the display.
# Options:
#   gpu       = Modern hardware-accelerated renderer (recommended)
#               Cross-platform, stable, excellent compatibility
#   gpu-next  = Experimental next-generation renderer
#               Cutting-edge features, may be unstable
#   sdl       = Software renderer using SDL2 library
#               Fallback for systems without GPU acceleration
#   direct3d  = Windows-specific Direct3D renderer (legacy)
#   xv        = X11 video extension (Linux, legacy)
#   drm       = Direct rendering manager (Linux framebuffer)
#   null      = No video output (audio-only testing)
vo=gpu

# GPU API selection
# Determines which graphics API mpv uses to communicate with your GPU.
# Options:
#   auto       = Automatically select best available API (recommended)
#                Priority: Vulkan > D3D11 > OpenGL
#   vulkan     = Modern low-overhead API, best performance
#                Requires recent drivers, may not work on older systems
#   d3d11      = Direct3D 11 (Windows only)
#                Excellent compatibility, good performance
#   opengl     = Legacy API, widest compatibility
#                Works on older hardware, slightly higher overhead
#   metal      = Apple's graphics API (macOS only)
#                Native performance on Mac systems
# Why 'auto'? Ensures optimal performance without manual intervention.
# Override only if experiencing driver issues with auto-detection.
gpu-api=auto

# Hardware decoding strategy
# Controls whether mpv offloads video decoding to GPU or uses CPU.
# Options:
#   no         = Force software (CPU) decoding for all formats
#                Highest compatibility, predictable behaviour
#                Higher CPU usage but eliminates driver-related issues
#   auto-safe  = Enable GPU decode only for known-safe formats
#                Conservative approach, balanced performance
#   auto       = Aggressive GPU decode for all supported formats
#                Maximum performance but may cause artefacts/crashes
#   auto-copy  = GPU decode with fallback copying to system RAM
#                Safer than 'auto', slight performance penalty
#   d3d11va    = Direct3D 11 Video Acceleration (Windows)
#   nvdec      = NVIDIA hardware decoder (CUDA-capable cards)
#   vaapi      = Video Acceleration API (Linux/Intel)
#   videotoolbox = Apple hardware decoder (macOS)
#   dxva2      = DirectX Video Acceleration 2 (Windows, legacy)
#   vdpau      = Video Decode and Presentation API (Linux/NVIDIA, legacy)
# Why 'no'? Broadcast files often use complex HEVC profiles (Main 10, high bitrate)
# that fail or produce grey screens with GPU hardware decoders. Software decode
# guarantees bit-perfect output at the cost of higher CPU usage.
hwdec=no

# Software decoder thread count
# Specifies how many CPU threads to allocate for video decoding when using
# software decode (hwdec=no). More threads = faster decode but higher CPU usage.
# Options:
#   0   = Auto-detect based on CPU core count (may use all cores)
#   1   = Single-threaded (slowest, lowest CPU usage)
#   4   = Quad-core systems
#   8   = Octa-core systems (recommended for modern CPUs)
#   16  = High-end workstations with 16+ cores
# Why '8'? Balances decode speed with system responsiveness on modern
# multi-core CPUs. Adjust based on your hardware and concurrent workload.
vd-lavc-threads=8

# ============================================================================
# VIDEO QUALITY & SCALING
# ============================================================================

# Upscaling algorithm
# Applied when source video resolution is smaller than display resolution.
# Determines how missing pixels are interpolated to fill the screen.
# Options:
#   bilinear          = Fastest, softest (not recommended for quality work)
#   lanczos           = Sharp, may introduce ringing artefacts
#   spline36          = Good balance, faster than ewa_lanczos
#   ewa_lanczos       = Excellent quality, elliptical weighted average
#   ewa_lanczossharp  = Enhanced sharpness with controlled ringing (recommended)
#   mitchell          = Balanced sharpness and smoothness
#   catmull_rom       = Sharp but can enhance noise
#   hermite           = Soft, fast
# Why 'ewa_lanczossharp'? Broadcast-quality sharpness with minimal artefacts.
# Computationally expensive but produces professional results. Balances detail
# preservation with clean edges, ideal for quality control workflows.
scale=ewa_lanczossharp

# Chroma upscaling algorithm
# Handles colour channel interpolation separately from luminance (brightness).
# Most video uses 4:2:0 chroma subsampling, meaning colour resolution is half
# of luminance resolution and requires upscaling.
# Options: (same as scale above)
#   bilinear, lanczos, spline36, ewa_lanczos, ewa_lanczossharp, mitchell, etc.
# Why 'ewa_lanczossharp'? Ensures colour accuracy matches luminance detail.
# Prevents colour fringing and maintains sharp colour edges in critical areas.
cscale=ewa_lanczossharp

# Downscaling algorithm
# Applied when source video resolution exceeds display resolution.
# Less critical than upscaling since you're reducing detail, not creating it.
# Options:
#   mitchell   = Smooth, natural downscaling (recommended)
#   hermite    = Softer, faster
#   lanczos    = Sharper but may alias
#   bilinear   = Fastest, acceptable quality
# Why 'mitchell'? Provides smooth, natural downscaling with minimal aliasing.
# Less computationally intensive than upscaling algorithms while maintaining
# good quality. Ideal for 4K → HD display scenarios.
dscale=mitchell

# Dithering algorithm
# Reduces colour banding in gradients by adding controlled noise patterns.
# Essential when displaying 10-bit source material on 8-bit displays.
# Options:
#   no                = Disable dithering (may show banding)
#   fruit             = Ordered dithering, good temporal stability (recommended)
#   ordered           = Simple ordered dithering, fast
#   error-diffusion   = Highest quality, more CPU intensive
# Why 'fruit'? Uses ordered dithering with good temporal stability, minimising
# flicker in gradients. Critical for 8-bit displays showing 10-bit broadcast
# content. Prevents visible colour banding in skies, shadows, and gradients.
dither=fruit

# Colour primaries target
# Defines the colour space (colour gamut) mpv aims to output.
# Ensures correct colour reproduction matching your display capabilities.
# Options:
#   auto           = Automatically match display capabilities (recommended)
#   bt.709         = Rec. 709 (HD/SDR standard, sRGB equivalent)
#   bt.2020        = Rec. 2020 (UHD/HDR wide colour gamut)
#   dci-p3         = Digital Cinema P3 (cinema/Mac displays)
#   adobe          = Adobe RGB (photography/print)
#   apple          = Apple RGB (legacy Mac)
#   prophoto       = ProPhoto RGB (photography)
# Why 'auto'? Automatically detects and matches your display's colour gamut
# (sRGB, P3, Rec.2020) without manual calibration. Ensures accurate colour
# reproduction across different monitors and viewing environments.
target-prim=auto

# Transfer characteristics (gamma curve)
# Defines how luminance values map to display brightness (EOTF).
# Critical for correct brightness and contrast reproduction.
# Options:
#   auto           = Automatically detect display EOTF (recommended)
#   bt.1886        = Rec. 1886 (standard for HD/SDR, gamma 2.4)
#   srgb           = sRGB transfer (gamma 2.2, PC standard)
#   gamma2.2       = Pure gamma 2.2 curve
#   gamma2.8       = Darker gamma 2.8 curve
#   pq             = Perceptual Quantizer (HDR10, SMPTE ST 2084)
#   hlg            = Hybrid Log-Gamma (HDR broadcast, BBC/NHK)
#   linear         = Linear light (no gamma correction)
# Why 'auto'? Detects your display's EOTF (sRGB, PQ, HLG) and adapts
# accordingly. Crucial for HDR content to display correctly on both SDR and
# HDR monitors without manual profile switching.
target-trc=auto

# ICC colour profile support
# Automatically load and apply display ICC profile for colour accuracy.
# ICC profiles contain monitor-specific colour calibration data.
# Options:
#   yes  = Auto-load ICC profile from system/display (recommended)
#   no   = Disable ICC profile loading
#   /path/to/profile.icc = Use specific ICC profile
# Why 'yes'? Ensures colour accuracy on calibrated displays by applying
# monitor-specific colour corrections. Essential for professional colour
# grading and quality control work. No effect on uncalibrated displays.
icc-profile-auto=yes

# Tone mapping algorithm
# Maps high dynamic range (HDR) content to standard dynamic range (SDR) displays.
# Only applies when playing HDR content on non-HDR monitors.
# Options:
#   hable          = Hable filmic tone mapping (recommended)
#                    Good default, cinematic look
#   mobius         = Mobius tone mapping
#                    Preserves detail in highlights, less contrast
#   reinhard       = Reinhard tone mapping
#                    Simple, fast, may crush details
#   bt.2390        = ITU-R BT.2390 (broadcast standard)
#                    Reference algorithm for broadcast HDR
#   gamma          = Simple gamma curve mapping
#   linear         = Linear mapping (clips highlights)
#   clip           = Hard clipping (not recommended)
# Why 'hable'? Provides natural-looking HDR → SDR conversion with good
# highlight preservation. Based on Uncharted 2 filmic tone mapping. Suitable
# for general content. Use 'bt.2390' for strict broadcast compliance.
tone-mapping=hable

# ============================================================================
# AUDIO CONFIGURATION
# ============================================================================

# Audio output channel layout
# Determines how multi-channel audio is mapped to your output device.
# Options:
#   auto       = Automatically match source and device (recommended)
#   stereo     = Force stereo downmix regardless of source
#   5.1        = Force 5.1 surround output
#   7.1        = Force 7.1 surround output
#   mono       = Force mono output
# Why 'auto'? Intelligently adapts to both source format and output device
# capabilities. Passes through multi-channel audio to surround systems,
# downmixes to stereo for headphones/speakers automatically.
audio-channels=auto

# Decoder downmix behaviour
# Controls whether the audio decoder itself performs downmixing or passes
# full channel layout to mpv for downmixing.
# Options:
#   yes  = Allow decoder to downmix multi-channel to stereo (recommended)
#   no   = Pass through all channels unchanged
# Why 'yes'? Enables proper centre channel extraction and LFE handling when
# downmixing surround formats. Produces better stereo fold-down than simple
# channel summing. Essential for broadcast QC with multi-channel sources.
ad-lavc-downmix=yes

# Normalise downmix levels
# Prevents clipping when downmixing multi-channel audio to stereo by adjusting
# gain levels according to ITU-R BS.775 recommendations.
# Options:
#   yes  = Adjust levels to prevent clipping (recommended)
#   no   = Preserve original levels (may clip)
# Why 'yes'? Prevents digital clipping and distortion when downmixing 5.1/7.1
# sources to stereo. Maintains proper loudness relationships between channels
# according to broadcast standards.
audio-normalize-downmix=yes

# Pitch correction during speed changes
# Maintains audio pitch when playing at non-1.0 speed (slow motion, fast forward).
# Options:
#   yes  = Maintain pitch (normal voice/music) (recommended)
#   no   = Allow pitch shift (chipmunk/slow-motion effect)
# Why 'yes'? Preserves natural sound during variable-speed playback. Essential
# for review workflows where you need to check audio content at different
# speeds without pitch distortion.
audio-pitch-correction=yes

# Audio buffer duration (seconds)
# Size of the audio buffer between decoder and output device.
# Larger buffer = more stable playback, higher latency.
# Options:
#   0.05 - 0.2  = Low latency (50-200ms), risk of underruns
#   0.5 - 1.0   = Balanced (recommended for most use)
#   1.0 - 2.0   = High stability, noticeable latency
# Why '1.0'? Provides stable playback without audible dropouts while keeping
# latency acceptable for interactive use. Adjust lower (0.2) for live
# monitoring, higher (2.0) for problematic playback scenarios.
audio-buffer=1.0

# Silence audio stream on pause
# Sends silence to audio device when playback is paused rather than stopping
# the audio stream entirely.
# Options:
#   yes  = Send silence when paused (recommended)
#   no   = Stop audio stream on pause
# Why 'yes'? Prevents popping, clicking, and audio device state changes when
# pausing/unpausing. Maintains continuous audio stream to device, eliminating
# audible artefacts during pause operations.
audio-stream-silence=yes

# Volume control
# Default playback volume as percentage.
# Options: 0-100 (or higher if volume-max allows)
# Why '100'? Starts at unity gain (0dB), no amplification or attenuation.
# Preserves original audio levels for accurate monitoring.
volume=100

# Maximum volume limit
# Allows volume control to exceed 100% for quiet content.
# Options: 100-200+ (percentage)
# Why '150'? Allows up to +3.5dB boost for quiet broadcast masters without
# risking excessive distortion. Higher values (200%+) may cause clipping.
volume-max=150

# ============================================================================
# ON-SCREEN DISPLAY (OSD)
# ============================================================================

# Built-in on-screen controller
# mpv's default playback controls and progress bar overlay.
# Options:
#   yes  = Enable default OSC with progress bar and controls
#   no   = Disable (use custom Lua scripts instead) (recommended)
# Why 'no'? We use custom Lua scripts (timecode.lua, audiomap.lua) that
# provide broadcast-specific overlays with timecode, frame numbers, and
# professional audio level monitoring.
osc=no

# Progress bar on seeking
# Controls whether a progress bar appears during seeking operations.
# Options:
#   yes  = Show progress bar
#   no   = No progress bar (recommended for custom OSD)
# Why 'no'? Custom timecode script provides superior progress visualisation
# with frame-accurate positioning. Built-in bar would conflict with custom
# overlay design.
osd-bar=no

# OSD content when seeking
# Determines what information displays during seek operations.
# Options:
#   bar      = Progress bar only (recommended)
#   msg      = Text message only (timestamp)
#   msg-bar  = Both progress bar and text message
#   no       = No OSD on seek
# Why 'bar'? Provides visual feedback during seeking without cluttering the
# display with redundant text (timecode script shows this information better).
osd-on-seek=bar

# OSD message duration (milliseconds)
# How long temporary OSD messages remain visible.
# Options: 500-5000 (milliseconds)
# Why '1500'? Provides 1.5 seconds to read messages without being intrusive.
# Balances readability with minimal screen clutter.
osd-duration=1500

# OSD font family
# Monospace font ensures alignment of timecode and technical information.
# Options: Any installed system font name
#   Consolas       = Clean monospace (Windows)
#   Courier New    = Classic monospace (cross-platform)
#   Monaco         = Clean monospace (macOS)
#   Liberation Mono = Open-source monospace (Linux)
# Why 'Consolas'? Excellent readability, good character spacing, professional
# appearance. Ideal for displaying technical data and timecodes.
osd-font="Consolas"

# OSD font size (pixels)
# Size of fallback OSD text (not used by custom scripts).
# Options: 16-72 (pixels)
# Why '32'? Readable without being obtrusive for default mpv messages.
osd-font-size=32

# OSD text colour (hex RGB)
# Foreground colour for OSD text.
# Options: #RRGGBB hex format
# Why '#FFFFFF'? White provides maximum contrast on most content. Universally
# readable across light and dark scenes with proper border/shadow.
osd-color="#FFFFFF"

# OSD border colour (hex RGB)
# Outline colour for OSD text, improves legibility.
# Options: #RRGGBB hex format
# Why '#000000'? Black border ensures text remains readable over any
# background colour. Standard broadcast practice for on-screen text.
osd-border-color="#000000"

# OSD border width (pixels)
# Thickness of text outline.
# Options: 0-8 (pixels)
# Why '2'? Provides clear separation from background without excessive weight.
# Maintains text readability without obscuring fine letterforms.
osd-border-size=2

# OSD shadow offset (pixels)
# Drop shadow distance from text, adds depth.
# Options: 0-8 (pixels)
# Why '2'? Subtle shadow improves perceived depth and readability. Matches
# border size for balanced appearance.
osd-shadow-offset=2

# OSD horizontal alignment
# Default position for OSD messages.
# Options: left, center, right
# Why 'left'? Standard position for technical information in broadcast
# workflows. Top-left corner is traditional for timecode and metadata.
osd-align-x=left

# OSD vertical alignment
# Default vertical position for OSD messages.
# Options: top, center, bottom
# Why 'top'? Keeps technical information away from action in lower portion
# of frame. Top-left is industry standard for monitoring overlays.
osd-align-y=top

# OSD horizontal margin (pixels)
# Distance from edge of screen to OSD text.
# Options: 0-100 (pixels)
# Why '24'? Provides comfortable spacing from screen edge without wasting
# space. Accounts for overscan on some displays.
osd-margin-x=24

# OSD vertical margin (pixels)
# Distance from top/bottom edge to OSD text.
# Options: 0-100 (pixels)
# Why '24'? Matches horizontal margin for visual consistency. Ensures text
# remains within action-safe area on broadcast monitors.
osd-margin-y=24

# ============================================================================
# PLAYBACK BEHAVIOUR
# ============================================================================

# Keep player open when file ends
# Controls whether mpv closes or remains open after playback completes.
# Options:
#   yes    = Stay open at last frame (recommended for QC)
#   no     = Close immediately after playback
#   always = Stay open even if file fails to load
# Why 'yes'? Essential for quality control workflows. Allows inspection of
# final frame, note-taking, and sequential file loading without restarting
# the player. Prevents accidental loss of session state.
keep-open=yes

# Pause at end of file
# Controls playback state when reaching end of file with keep-open enabled.
# Options:
#   yes  = Pause on last frame
#   no   = Continue to stay at end without pausing (recommended)
# Why 'no'? When keep-open is enabled, continuing without pause allows
# immediate seeking or loading next file. Pausing requires manual unpause
# action which adds unnecessary step in QC workflows.
keep-open-pause=no

# Loop file behaviour
# Controls automatic replay of current file.
# Options:
#   no   = Play once (recommended for QC)
#   inf  = Loop forever
#   N    = Loop N times (integer)
# Why 'no'? Quality control requires linear playback with deliberate
# navigation. Automatic looping would interfere with systematic review
# processes. Enable manually when needed for specific use cases.
loop-file=no

# ============================================================================
# SEEKING & NAVIGATION
# ============================================================================

# High-resolution seeking
# Enables frame-accurate seeking by decoding to exact timestamp.
# Options:
#   yes  = Frame-accurate seeking (essential for QC)
#   no   = Keyframe-only seeking (faster but imprecise)
# Why 'yes'? Absolutely essential for quality control and broadcast workflows.
# Ensures seeking lands on exact frames, not just nearest keyframes. Critical
# for reviewing specific issues, creating edit decision lists, and frame-
# accurate timecode annotation.
hr-seek=yes

# Frame dropping during seeking
# Controls whether frames are skipped during seek operations for speed.
# Options:
#   yes  = Drop frames for faster seeking
#   no   = Decode all frames (slower but accurate) (recommended)
# Why 'no'? Slower seeking is acceptable trade-off for guaranteed accuracy.
# Ensures seeking displays correct frames without artefacts from dropped
# decoding. Critical for landing on exact frames during QC review.
hr-seek-framedrop=no

# ============================================================================
# CACHING & BUFFERING
# ============================================================================

# Enable cache for all playback
# Buffers media data in RAM for smoother scrubbing and seeking.
# Options:
#   yes  = Enable cache (recommended)
#   no   = Direct playback without buffering
#   auto = Enable only for network streams
# Why 'yes'? Provides smooth scrubbing through large files by pre-loading
# data into RAM. Essential for efficient QC workflows with frequent seeking.
# Prevents re-reading from disk on every seek operation.
cache=yes

# Cache duration (seconds)
# How many seconds of video to pre-buffer.
# Options: 5-60 (seconds)
# Why '10'? Balances RAM usage with smooth scrubbing capability. Provides
# sufficient buffer for most seek operations without excessive memory
# consumption. Increase to 30+ for very large files or slow storage.
cache-secs=10

# Maximum cache size (bytes)
# Upper limit for demuxer buffer size regardless of cache-secs setting.
# Options: 50M-2G (M=megabytes, G=gigabytes)
# Why '500M'? Allows buffering several seconds of high-bitrate broadcast
# material (4K, multi-channel audio) without hitting memory limits. Adjust
# based on file bitrate: 4K HDR may need 1G, HD can use 200M.
demuxer-max-bytes=500M

# Read-ahead duration (seconds)
# How far ahead demuxer reads when initially buffering or after seeking.
# Options: 10-60 (seconds)
# Why '20'? Provides substantial buffer for smooth playback during analysis.
# Prevents buffering pauses during intense processing or multi-tasking.
# Higher values (60s) beneficial for unreliable storage media.
demuxer-readahead-secs=20

# Backwards cache size (bytes)
# Amount of already-played data kept in buffer for backwards seeking.
# Options: 50M-500M
# Why '200M'? Allows seeking backwards several seconds without re-reading
# from disk. Essential for QC workflows involving repeated review of specific
# segments. Larger values enable more backwards seeking range.
demuxer-max-back-bytes=200M

# ============================================================================
# SCREENSHOT CONFIGURATION
# ============================================================================

# Screenshot format
# File format for captured frames.
# Options:
#   png   = Lossless, large files (recommended for QC)
#   jpg   = Lossy compression, smaller files
#   webp  = Modern format, good compression with quality
# Why 'png'? Lossless format preserves exact pixel data for quality control
# documentation. No compression artefacts. Essential for creating reference
# images, bug reports, and frame comparisons.
screenshot-format=png

# PNG compression level
# Balance between file size and encoding speed.
# Options: 0-9
#   0 = No compression (fastest, largest files)
#   5 = Balanced (recommended)
#   9 = Maximum compression (slowest, smallest files)
# Why '5'? Good balance between file size and capture speed. Higher values
# (7-9) beneficial for archival, lower (1-3) for rapid capture sessions.
screenshot-png-compression=5

# Screenshot filename template
# Pattern for naming screenshot files automatically.
# Variables:
#   %F = Filename without extension
#   %f = Filename with extension
#   %p = Current playback position (timestamp)
#   %P = Playback position in HH:MM:SS format
#   %n = Sequential number
#   %wH, %wM, %wS = Hour, minute, second (width-padded)
# Why '%F_frame_%p'? Clearly identifies source file and exact timestamp.
# Enables easy correlation of screenshots with source material. Example:
# "video_frame_01:23:45.678.png" shows exact frame location.
screenshot-template="%F_frame_%p"

# Screenshot save directory
# Location where screenshot files are saved.
# Options:
#   ~/path       = Relative to home directory (cross-platform)
#   /abs/path    = Absolute path
#   .            = Current working directory
# Why '~/mpv_screenshots'? Centralised location for all screenshots,
# independent of source file location. Prevents cluttering source directories.
# Easy to locate and manage captured frames.
screenshot-directory="~/mpv_screenshots"

# High bit-depth screenshots
# Preserve 10-bit/12-bit colour depth in screenshots when source supports it.
# Options:
#   yes  = Preserve high bit-depth (recommended for broadcast)
#   no   = Convert to 8-bit
# Why 'yes'? Preserves full colour precision of 10-bit broadcast masters.
# Essential for documenting colour banding, gradient issues, and HDR content.
# 8-bit conversion would lose critical information for QC analysis.
screenshot-high-bit-depth=yes

# Screenshot source
# Determines what gets captured in screenshots.
# Options:
#   no      = Capture raw video frame without subtitles (recommended)
#   yes     = Capture after subtitle rendering
#   video   = Alias for 'no'
#   window  = Capture entire player window including GUI
# Why 'no'? Captures clean video frames without overlays for technical
# documentation. Subtitles and OSD elements would interfere with frame
# analysis. Use 'yes' only when documenting subtitle rendering issues.
screenshot-sw=no

# ============================================================================
# SUBTITLE CONFIGURATION
# ============================================================================

# Automatic subtitle loading
# Controls how mpv searches for and loads subtitle files.
# Options:
#   no     = Don't auto-load subtitles
#   exact  = Load only if filename matches exactly
#   fuzzy  = Load if filename is similar (recommended)
#   all    = Load all subtitle files in directory
# Why 'fuzzy'? Intelligently loads subtitles with similar filenames while
# avoiding unrelated files. Handles common naming variations (video.mkv →
# video.en.srt, video_eng.srt) without loading every subtitle in folder.
sub-auto=fuzzy

# Subtitle font family
# Font used for rendering text subtitles.
# Options: Any installed system font
# Why 'Arial'? Clean, highly legible sans-serif font with excellent Unicode
# support. Industry-standard for broadcast subtitles. Neutral appearance
# doesn't distract from content.
sub-font="Arial"

# Subtitle font size
# Base size for subtitle text.
# Options: 24-72 (points)
# Why '48'? Large enough to read comfortably at typical viewing distances
# without obscuring significant picture area. Scales appropriately with
# different display resolutions.
sub-font-size=48

# Subtitle text colour (hex RGB)
# Foreground colour for subtitle text.
# Options: #RRGGBB format
# Why '#FFFFFF'? White is broadcast standard for subtitle text. Maximum
# contrast on dark scenes, acceptable on light scenes with proper border.
sub-color="#FFFFFF"

# Subtitle border colour (hex RGB)
# Outline colour surrounding subtitle text for legibility.
# Options: #RRGGBB format
# Why '#000000'? Black border ensures readability over any background.
# Standard practice in broadcast and streaming. Provides clear separation
# without colour distraction.
sub-border-color="#000000"

# Subtitle border width
# Thickness of outline around subtitle text.
# Options: 0-8 (points)
# Why '2.5'? Substantial outline ensures readability without excessive weight.
# Thicker than OSD border (2) as subtitles may appear over complex backgrounds.
# Broadcast-standard weight for on-screen text.
sub-border-size=2.5

# Subtitle shadow offset
# Distance of drop shadow from subtitle text.
# Options: 0-8 (points)
# Why '1'? Subtle shadow adds depth without overwhelming border. Lighter than
# OSD shadow as subtitle border is already substantial. Improves perceived
# separation from background.
sub-shadow-offset=1

# Subtitle shadow colour (hex RGB)
# Colour of drop shadow beneath subtitle text.
# Options: #RRGGBB format
# Why '#000000'? Black shadow reinforces border effect. Increases effective
# contrast when white text appears over bright backgrounds.
sub-shadow-color="#000000"

# Subtitle vertical position
# Distance from bottom of screen as percentage.
# Options: 0-100 (percentage from bottom)
# Why '95'? Places subtitles near bottom while remaining within safe area.
# Leaves room for custom OSD elements (timecode, progress bar) without
# overlap. Standard broadcast positioning.
sub-pos=95

# ============================================================================
# WINDOW & DISPLAY
# ============================================================================

# Force window creation
# Controls when mpv creates its display window.
# Options:
#   no         = Wait for user action
#   yes        = Create window when starting playback
#   immediate  = Create window before loading file (recommended)
# Why 'immediate'? Allows placing window in desired location before playback
# begins. Essential for multi-monitor workflows where window position matters.
# Prevents window appearing on wrong display during file load.
force-window=immediate

# Default window size
# Initial window dimensions when not in fullscreen.
# Options:
#   WxH        = Specific width × height in pixels (e.g., 1920x1080)
#   N%         = Percentage of screen height (recommended)
#   WxH%       = Percentage of width × height
# Why '85%'? Provides large viewing area while leaving space for system UI
# (taskbar, dock). Prevents window from covering entire screen, allowing
# access to other applications. Automatically adapts to display size.
autofit=85%

# Window always on top
# Forces player window to stay above other windows.
# Options:
#   yes  = Always on top
#   no   = Normal window stacking behaviour (recommended)
# Why 'no'? Allows flexible window management. Quality control often involves
# comparing video with reference materials, documentation, or other tools.
# Always-on-top would prevent efficient multi-window workflows. Enable
# manually when needed.
ontop=no

# Window border and decorations
# Controls whether window has title bar and borders.
# Options:
#   yes  = Show window decorations (recommended)
#   no   = Borderless window
# Why 'yes'? Title bar shows filename for quick reference. Window controls
# provide standard close/minimize/maximize functionality. Borders enable
# resizing. Borderless mode better suited for fullscreen presentations.
border=yes

# Title bar text format
# Pattern for window title text.
# Variables:
#   ${filename}      = Full filename with extension
#   ${media-title}   = Title from metadata (if available)
#   ${chapter}       = Current chapter number/name
#   ${?var:text}     = Show text only if var exists
#   ${!var:text}     = Show text only if var doesn't exist
# Why this pattern? Shows media title from metadata if available (professional
# files often have descriptive titles), falls back to "No file" for empty
# player. Provides clear identification in taskbar and window switchers.
title="${?media-title:${media-title}}${!media-title:No file}"

# ============================================================================
# FULLSCREEN
# ============================================================================

# Start in fullscreen mode
# Controls initial display mode when launching mpv.
# Options:
#   yes  = Always start fullscreen
#   no   = Start in windowed mode (recommended)
# Why 'no'? Windowed mode provides better integration with multi-monitor
# workflows and simultaneous tool usage. Fullscreen easily toggled with 'f'
# key when needed. Starting windowed allows positioning before expanding.
fs=no

# Fullscreen target monitor
# Selects which display to use for fullscreen mode.
# Options:
#   0        = Primary monitor
#   1, 2...  = Secondary monitors (numbered)
#   current  = Monitor where window currently resides
# Why '0'? Primary monitor is typically the main working display. Consistent
# behaviour across sessions. Change to '1' or '2' for dedicated QC monitor
# in multi-display broadcast facilities.
fs-screen=0

# ============================================================================
# CACHE DIRECTORIES
# ============================================================================

# GPU shader cache directory
# Location where compiled GPU shaders are stored for faster startup.
# Options: Any writable directory path
#   ~/.cache/mpv/shaders  = Standard location (Linux/macOS)
#   ~/AppData/mpv/cache   = Windows equivalent
# Why this path? Cross-platform standard location for cache files. Compiled
# shaders significantly improve subsequent startup times (5-10 second
# improvement). Separate from config allows easy cleanup without losing
# settings. Size typically 10-50MB depending on shader complexity.
gpu-shader-cache-dir="~/.cache/mpv/shaders"

# ICC profile cache directory
# Location where parsed ICC colour profiles are cached.
# Options: Any writable directory path
# Why separate cache? ICC profile parsing can take 1-2 seconds on startup.
# Caching eliminates this delay on subsequent launches. Profiles rarely
# change, making caching highly effective. Size typically <5MB.
icc-cache-dir="~/.cache/mpv/icc"

# ============================================================================
# FILE HANDLING
# ============================================================================

# Ordered chapters (Matroska)
# Controls whether mpv follows ordered chapter links in Matroska files.
# Ordered chapters allow splitting files across multiple segments while
# maintaining continuous playback.
# Options:
#   yes  = Follow chapter links (recommended)
#   no   = Ignore, play current file only
# Why 'yes'? Some broadcast archives use ordered chapters for multi-segment
# masters. Enables seamless playback across file boundaries. No performance
# penalty if feature isn't used in file. Disable only if experiencing issues
# with specific problematic files.
ordered-chapters=yes

# Merge external files
# Controls automatic merging of external audio/subtitle tracks.
# Options:
#   yes  = Automatically merge external tracks
#   no   = Treat each file separately (recommended)
# Why 'no'? Quality control requires explicit control over which files are
# playing. Auto-merging could lead to reviewing wrong combinations. External
# tracks should be loaded deliberately using --audio-file or --sub-file
# command-line options.
merge-files=no

# Resume playback position
# Remembers playback position for each file and resumes on next open.
# Options:
#   yes  = Remember and resume positions
#   no   = Always start from beginning (recommended for QC)
# Why 'no'? Quality control workflows require reviewing files from start.
# Auto-resume would skip portions and interfere with systematic review.
# Position saved in watch-later directory as state files. Enable for
# personal viewing, disable for professional QC work.
save-position-on-quit=no

# Watch-later state directory
# Location where playback position and state are saved when save-position
# is enabled.
# Options: Any writable directory path
# Why this path? Standard location for session state. Even with save-position
# disabled, directory must exist for mpv to function correctly. Size grows
# with number of files played (few KB per file).
watch-later-directory="~/.config/mpv/watch_later"

# ============================================================================
# NETWORK STREAMING
# ============================================================================

# User agent for HTTP streams
# Identifies mpv to HTTP servers when requesting network streams.
# Options:
#   "mpv ${mpv-version}" = Standard identification (recommended)
#   "Mozilla/5.0..."     = Browser impersonation (for restrictive servers)
#   Custom string        = Any user agent string
# Why default? Honest identification. Most servers accept mpv. Change only if
# encountering 403 Forbidden errors or user-agent blocking on specific streams.
# ${mpv-version} automatically inserts current version number.
user-agent="mpv ${mpv-version}"

# Network timeout (seconds)
# Maximum time to wait for network operations before giving up.
# Options: 10-120 (seconds)
# Why '60'? Accommodates slow or congested networks without excessive waiting.
# Long enough for most legitimate delays, short enough to detect dead
# connections. Increase to 120 for satellite/poor connections, decrease to
# 30 for fast local networks.
network-timeout=60

# Stream cache buffer size
# Initial buffer size for network streams before playback begins.
# Options: 1M-16M (M = megabytes)
# Why '4M'? Provides 4MB buffer for smooth startup of network streams.
# Sufficient for HD streaming without excessive delay. Increase to 8M for
# 4K streams, decrease to 2M for low-latency monitoring. Separate from main
# cache (cache-secs), applies only to network protocols.
stream-buffer-size=4M

# ============================================================================
# LOGGING & DEBUG
# ============================================================================

# Terminal progress bar
# Shows playback progress as ASCII art bar in terminal window.
# Options:
#   yes  = Display progress bar in terminal (recommended)
#   no   = No terminal output
# Why 'yes'? Provides playback status feedback when GUI is not visible.
# Useful for headless operation, background playback, or when monitoring
# terminal for errors. No performance impact. Disable only for scripted
# batch processing where terminal output would clutter logs.
term-osd-bar=yes

# Message verbosity level
# Controls amount of information mpv prints to terminal/log.
# Options (per component or globally):
#   fatal  = Only fatal errors that prevent operation
#   error  = Errors and fatal messages
#   warn   = Warnings, errors, and fatal messages
#   info   = Informational messages plus above
#   status = Playback status updates plus above
#   v      = Verbose output plus above
#   debug  = Debug information plus above
#   trace  = Extremely detailed trace information (development)
# Format: component=level or all=level
# Examples:
#   msg-level=all=info          = Info level for all components
#   msg-level=vo=debug,ao=trace = Debug video, trace audio
# Why commented? Default info level suitable for normal use. Uncomment and
# adjust for troubleshooting. Use 'trace' only when diagnosing specific
# issues - generates huge amounts of output.
# msg-level=all=info

# Log file path
# Redirects mpv messages to file instead of/in addition to terminal.
# Options: Any writable file path
# Why commented? Logging to file useful for troubleshooting intermittent
# issues or batch processing. Uncomment and set path when systematic logging
# needed. File can grow large (MB per hour), implement rotation for
# long-running sessions.
# log-file=~/mpv.log

# ============================================================================
# PROFILES
# ============================================================================
# Profiles allow quick switching between different configurations.
# They override settings above but can be overridden by command-line options.
#
# Activation methods:
#   Command line: mpv --profile=profile-name file.mp4
#   During playback: Press ` (backtick), type: apply-profile profile-name
#   Multiple profiles: mpv --profile=qc-accurate --profile=hdr file.mp4
#   Auto-apply: Use [profile-cond] sections for conditional application
#
# Priority order (highest to lowest):
#   1. Command-line options
#   2. Profiles applied during playback
#   3. Profiles specified on command-line
#   4. Settings in this file
#   5. mpv built-in defaults

# ──────────────────────────────────────────────────────────────────────────
# Quality Control Profile (Frame-Accurate Playback)
# ──────────────────────────────────────────────────────────────────────────
# Absolute frame accuracy for broadcast quality control workflows.
# Eliminates all forms of frame dropping, interpolation, and sync adjustment.
# Use when: Reviewing broadcast masters, creating EDLs, frame-accurate QC

[qc-accurate]
profile-desc="QC Mode: Frame-accurate playback for quality control"

# Video synchronisation mode
# Controls how mpv maintains sync between audio and video streams.
# Options:
#   audio             = Use audio as master clock (recommended for QC)
#                       Video displays at exact container timestamps
#   display-resample  = Resample to display refresh rate (smooth but not frame-accurate)
#   display-vdrop     = Drop video frames to match display
#   display-adrop     = Drop audio samples to match display
#   desync            = No sync, fastest but drifts apart
# Why 'audio'? Guarantees every video frame displays according to its exact
# timestamp in the file. No frame duplication or skipping. This is the ONLY
# mode suitable for frame-accurate quality control. System may stutter if
# unable to keep up, but no frames are lost or duplicated.
video-sync=audio

# Frame interpolation (motion smoothing)
# Generates artificial intermediate frames between real frames.
# Options:
#   yes  = Enable interpolation (smooth motion)
#   no   = Display only real frames (recommended for QC)
# Why 'no'? Interpolation creates frames that don't exist in source material.
# Disastrous for QC work where you must see actual encoded frames. Any
# artefacts or issues in real frames would be masked by synthetic frames.
# Enable only for personal viewing of 24fps content on 60Hz displays.
interpolation=no

# Frame dropping
# Allows skipping frames when system cannot maintain real-time playback.
# Options:
#   no   = Never drop frames (recommended for QC)
#   vo   = Drop frames at video output stage
#   decoder = Drop frames at decoder stage (more aggressive)
# Why 'no'? Every frame must be visible for quality control. System may
# stutter or slow down if unable to decode in real-time, but all frames
# will eventually display. Stuttering is preferable to missed frames when
# reviewing for technical issues or defects.
framedrop=no

# High-resolution seek frame dropping
# Controls frame dropping during seek operations specifically.
# Options:
#   yes  = Drop frames during seeking for speed
#   no   = Decode all frames during seeking (recommended for QC)
# Why 'no'? Guarantees seeking lands on exact intended frame without
# artefacts from incomplete decoding. Slower seeking is acceptable trade-off
# for guaranteed accuracy. Critical when navigating to specific timecodes
# or frame numbers for review.
hr-seek-framedrop=no

# Deinterlacing
# Automatically removes interlacing artefacts from interlaced content.
# Options:
#   no    = No automatic deinterlacing (recommended for modern content)
#   auto  = Deinterlace only if content is detected as interlaced
#   yes   = Always deinterlace (not recommended)
# Why 'no'? Modern broadcast content is progressive (1080p, 2160p). Automatic
# deinterlacing adds processing overhead and may incorrectly trigger on
# progressive content with interlaced artefacts. Enable manually with 'd'
# key if reviewing legacy interlaced material (1080i, 576i, 480i).
deinterlace=no

# Hardware decoding override
# Ensures software decode is used even if global setting differs.
# Why explicit? Provides failsafe if global hwdec setting is changed or
# overridden elsewhere. Guarantees this profile always uses software decode
# for maximum compatibility with complex broadcast codecs.
hwdec=no

# Software decoder threads
# Redundant with global setting but ensures this profile uses optimal
# thread count for software decode.
vd-lavc-threads=8

# ──────────────────────────────────────────────────────────────────────────
# Real-Time Monitoring Profile
# ──────────────────────────────────────────────────────────────────────────
# Prioritises smooth playback over frame accuracy.
# Use when: Live monitoring, real-time ingest review, smooth preview playback

[qc-realtime]
profile-desc="Real-time monitoring mode (smooth playback priority)"

# Smooth playback via display resampling
# Synchronises video to display refresh rate for judder-free playback.
# Trade-off: Frame accuracy sacrificed for smoothness.
video-sync=display-resample

# Enable interpolation for smooth motion
# Generates intermediate frames for smoother motion appearance.
interpolation=yes

# Allow frame dropping to maintain sync
# Permits dropping frames if system cannot maintain real-time decode.
# Options: vo, decoder, no
framedrop=vo

# ──────────────────────────────────────────────────────────────────────────
# HDR Content Profile
# ──────────────────────────────────────────────────────────────────────────
# Optimised colour handling for high dynamic range content.
# Use when: Reviewing HDR10, HLG, or Dolby Vision masters

[hdr]
profile-desc="HDR content optimisation (PQ/HLG tone mapping)"

# PQ transfer function for HDR10 content
# Perceptual Quantizer (SMPTE ST 2084) is standard for HDR10.
# Options: pq, hlg, auto
target-trc=pq

# Wide colour gamut for HDR content
# Rec. 2020 is standard colour space for UHD/HDR broadcast.
# Options: bt.2020, bt.709, dci-p3, auto
target-prim=bt.2020

# ITU broadcast standard tone mapping
# BT.2390 is reference algorithm for broadcast HDR → SDR conversion.
# Use when viewing HDR content on SDR displays.
# Options: bt.2390, hable, mobius, reinhard
tone-mapping=bt.2390

# ──────────────────────────────────────────────────────────────────────────
# Slow Motion Analysis Profile
# ──────────────────────────────────────────────────────────────────────────
# Reduces playback speed for detailed frame-by-frame analysis.
# Use when: Inspecting motion artefacts, compression issues, or fast action

[slowmo]
profile-desc="Slow-motion review at 0.25x speed"

# Quarter-speed playback
# Allows detailed examination of fast motion or subtle artefacts.
# Options: 0.01-100 (1.0 = normal speed)
speed=0.25

# Disable pitch correction
# Allows hearing audio at reduced speed without pitch shifting.
# Useful for analysing audio sync issues or dialogue clarity.
# Options: yes (maintain pitch), no (allow pitch shift)
audio-pitch-correction=no

# ──────────────────────────────────────────────────────────────────────────
# Large File Optimisation Profile
# ──────────────────────────────────────────────────────────────────────────
# Enhanced buffering for very large broadcast files.
# Use when: Working with >50GB masters, high-bitrate 4K, long-duration files

[large-files]
profile-desc="Optimisation for large files (>50GB)"

# 1GB demuxer buffer
# Allows buffering more data for smoother scrubbing in huge files.
# Options: 100M-2G (M=megabytes, G=gigabytes)
demuxer-max-bytes=1G

# 60 seconds read-ahead
# Pre-loads substantial amount of content for uninterrupted playback.
# Options: 10-120 (seconds)
demuxer-readahead-secs=60

# 30 seconds cache
# Maintains large cache for smooth operation during analysis.
# Options: 5-60 (seconds)
cache-secs=30

# 500MB backwards buffer
# Enables extensive backwards seeking without re-reading from storage.
# Options: 100M-1G
demuxer-max-back-bytes=500M

# ──────────────────────────────────────────────────────────────────────────
# Low Latency Profile
# ──────────────────────────────────────────────────────────────────────────
# Minimal delay for live monitoring and ingest QC.
# Use when: Monitoring live feeds, checking encoder output in real-time

[low-latency]
profile-desc="Minimal latency for live monitoring"

# Disable cache
# Eliminates buffering delay for immediate playback.
# Options: yes, no, auto
cache=no

# Audio master clock sync
# Most reliable sync method for low-latency scenarios.
video-sync=audio

# Disable interpolation
# Removes processing delay from frame generation.
interpolation=no

# 50ms audio buffer
# Absolute minimum buffer for stable audio output.
# Options: 0.02-2.0 (seconds)
audio-buffer=0.05

# Untimed mode
# Ignores container timestamps for immediate display.
# Useful for live streams where timing may be unreliable.
# Options: yes, no
untimed=yes

# ──────────────────────────────────────────────────────────────────────────
# Network Stream Monitoring Profile
# ──────────────────────────────────────────────────────────────────────────
# Optimised for UDP/RTP/RTMP/SRT live stream monitoring.
# Use when: Monitoring contribution feeds, checking stream encoders

[stream-monitor]
profile-desc="Live stream monitoring (UDP/RTMP/SRT protocols)"

# Enable cache with minimal delay
# Small buffer balances stability with low latency.
cache=yes

# 2 second cache
# Sufficient for network jitter without excessive delay.
# Options: 1-5 (seconds)
cache-secs=2

# 2 second read-ahead
# Matches cache duration for consistent buffering.
demuxer-readahead-secs=2

# Audio master clock
# Most stable sync for variable-rate network streams.
video-sync=audio

# Allow frame dropping
# Maintains sync if network cannot deliver frames in time.
framedrop=vo

# Untimed mode
# Handles streams with irregular or missing timestamps.
untimed=yes

# ──────────────────────────────────────────────────────────────────────────
# Broadcast Standard Profiles
# ──────────────────────────────────────────────────────────────────────────
# Quick presets for specific broadcast standards.

[broadcast-pal]
profile-desc="PAL broadcast standard (50 fps, 576i/720p/1080i)"
# Add PAL-specific settings here if needed (e.g., deinterlace=yes for 576i)

[broadcast-ntsc]
profile-desc="NTSC broadcast standard (59.94 fps, 480i/720p/1080i)"
# Add NTSC-specific settings here if needed

# ============================================================================
# NOTES & USAGE EXAMPLES
# ============================================================================
#
# Testing Configuration:
#   mpv --msg-level=all=info test.mp4
#   Shows detailed information about active settings and loaded profiles
#
# Combining Profiles:
#   mpv --profile=qc-accurate --profile=hdr master.mp4
#   Applies both profiles in sequence (later profiles override earlier ones)
#
# Temporary Overrides:
#   mpv --profile=qc-accurate --speed=0.5 file.mp4
#   Command-line options override profile settings
#
# Profile During Playback:
#   Press ` (backtick) to open console
#   Type: apply-profile slowmo
#   Changes settings without restarting playback
#
# Checking Active Settings:
#   mpv --show-profile=qc-accurate
#   Displays all settings contained in specified profile
#
# Listing All Profiles:
#   mpv --profile=help
#   Shows all available profiles with descriptions
#
# Documentation:
#   man mpv                          (comprehensive manual)
#   https://mpv.io/manual/stable/    (online documentation)
#   mpv --list-options               (all available options)
#
# ============================================================================